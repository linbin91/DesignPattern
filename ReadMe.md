### 归纳点

##### 单利模式
需要把构造函数设置为private,以及如果用延时加载的话，需要加锁保证多线程问题

##### 抽象工厂模式和工厂模式的区别

工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类只能创建一个具体产品类的实例。  抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类可以创建多个具体产品类的实例。         区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。    工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个

[参考](https://www.zhihu.com/question/20367734/answer/15088661)

##### 适配器(Adapter)模式
角色介绍

目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。

源(Adapee)角色：现在需要适配的接口。

适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类

Android的做法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter的接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的Item View 通过代理数据集来告知ListView数据的个数( getCount函数 )以及每个数据的类型( getItem函数 )，最重要的是要解决Item View的输出


##### 桥接模式
将抽象部分与实现(行为)部分分离，使它们都可以独立的变化。

桥接模式的做法是把变化部分(实现)抽象出来，使变化部分与主类(抽象)分离开来，从而将多个维度(这里相当于具体的实现子类,如Engine200,Engine300)的变化彻底分离。最后，提供一个管理类(如下面的引擎类)来组合不同维度上的变化，通过这种组合来满足业务的需要

[参考](https://blog.csdn.net/qq_32575047/article/details/79671146)
##### 建造者模式

优点

良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节；

建造者独立，容易扩展；

在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。

缺点

会产生多余的Builder对象以及Director对象，消耗内存；

对象的构建过程暴露。


##### 责任链

一个请求沿着一条“链”传递，直到该“链”上的某个处理者处理它为止。

Android中关于责任链模式比较明显的体现就是在事件分发过程中对事件的投递

##### 命令模式

命令模式涉及到五个角色，他们分别是：


客户端角色(Client)：创建一个具体命令ConcreteCommand对象并确定其接收者。

命令角色(Command)： 声明一个给所有具体命令类的抽象接口。

具体命令角色(ConcreteCommand)：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。

请求者角色(Invoker)：负责调用命令对象执行请求，相关的方法叫做行动方法。

接收者角色(Receiver)：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。

[参考](https://www.jianshu.com/p/5901e76a6348)

##### 装饰者模式

Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为

ConcreteComponent：定义具体对象，即被装饰者

Decorator：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类

ConcreteDecorator：具体装饰者，用于扩展ConcreteComponent

[参考](https://www.jianshu.com/p/c26b9b4a9d9e)

[参考](https://blog.csdn.net/qian520ao/article/details/82529890)


##### 代理模式

抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。

目标对象角色：定义了代理对象所代表的目标对象。

代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。

代理模式在Binder中的使用

[参考](https://github.com/JackChan1999/DesignPattern/tree/master/proxy)


##### 观察者模式
Android

当ListView的数据发生变化时，调用Adapter的notifyDataSetChanged()方法，这个方法又会调用DataSetObservable的notifyChanged()方法，这个方法会调用所有观察者（AdapterDataSetObserver）的onChange()方法，在onChange()方法中又会调用ListView重新布局的方法requestLayout()使得ListView刷新界面

[参考](https://github.com/JackChan1999/DesignPattern/blob/master/observer/%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)

##### 外观模式
提供一个高层次的接口，使得子系统更易于使用。因此在不使用该模式的情况下，客户端程序使用相关功能的成本就会比较的复杂，需要和各个子系统进行交互 ( 如上图 )，这样就使得系统的稳定性受到影响，用户的使用成本也相对较高。

在开发过程中，Context是最重要的一个类型。它封装了很多重要的操作，比如startActivity()、sendBroadcast()等，几乎是开发者对应用操作的统一入口。Context是一个抽象类，它只是定义了抽象接口，真正的实现在ContextImpl类中。它就是今天我们要分析的外观类

##### 享元模式

如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝,而不必为每一次使用都创建新的对象。在享元模式中，由于需要构造和维护这些可以共享的对象，因此，常会出现一个工厂类，用于维护和创建对象

Android Message消息池没有使用Map这样的容器，使用的是链表。在回收Message时把该对象添加到链表中


##### 原型模式

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

优点 原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

缺点 这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。